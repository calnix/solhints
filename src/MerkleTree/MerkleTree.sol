// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract MerkleVerifier {
    
    // The root of the merkle tree, generated by constructTree().
    bytes32 public immutable ROOT;

    // Whether a member has claimed their drop.
    // Note this assumes each members is only eligible for a single drop
    mapping (address => bool) public hasClaimed;

    constructor(bytes32 root) payable {
        ROOT = root;
    }

    // Given a leaf hash in a merkle tree and a list of sibling hashes/nodes,
    // attempt to arrive at the root hash, returning true if we got there.
    function verify(bytes32 leaf, bytes32[] memory siblings) public view returns (bool) {
        // In a sparse tree, empty leaves have a value of 0, so don't allow 0 as input.
        require(leaf != 0, 'invalid leaf value');

        bytes32 node = leaf;

        for (uint256 i = 0; i < siblings.length; ++i) {
            bytes32 sibling = siblings[i];
            node = keccak256(
                // Siblings are always hashed in sorted order.
                node > sibling ? abi.encode(sibling, node) : abi.encode(node, sibling)
            );
        }
        return node == ROOT;
    }

    // Claim a drop on behalf of a member, given a proof that their claim belongs to the merkle tree.
    function claim(address payable member, uint256 claimAmount, bytes32[] memory proof) external {
        require(!hasClaimed[member], 'already claimed');

        // Security note: Leaf hashes are inverted to prevent second preimage attacks,
        // i.e., passing in intermediate node values (subtree hashes) for member and claimAmount.
        require(verify(~keccak256(abi.encode(member, claimAmount)), proof), 'bad proof');
        hasClaimed[member] = true;
        member.transfer(claimAmount);
    }
}   

// Utils for generating merkle trees and proofs. Normally this would be implemented off-chain.
contract TreeCreator {
    // Construct a sparse merkle tree from a list of members and respective claim amounts. 
    // This tree will be sparse in the sense that rather than padding tree levels to the next power of 2, missing nodes will default to a value of 0.

    // give addresses and their respective claimAmounts. assume sorted. 
    function constructTree(address[] memory members, uint256[] memory claimAmounts) external pure returns (bytes32 root, bytes32[][] memory tree) {
        require(members.length != 0 && members.length == claimAmounts.length);
        
        // Determine tree height: keep dividing no. of leaves by 2 till you get 1
        uint256 height = 0;
        {
            uint256 n = members.length; // no. of leaves
            while (n != 0) {
                n = n == 1 ? 0 : (n + 1) / 2;   // n+1: cos index starts from 0. 
                ++height;
            }
        }
        tree = new bytes32[][](height);     // 2-D array: bytes32[][height]tree. top-level is height.

        // The first layer of the tree contains the leaf nodes, which are hashes of each member and claim amount.
        bytes32[] memory nodes = tree[0] = new bytes32[](members.length);

        for (uint256 i = 0; i < members.length; ++i) {
            // Leaf hashes are inverted to prevent second preimage attacks.
            nodes[i] = ~keccak256(abi.encode(members[i], claimAmounts[i]));
        }

        // Build up subsequent layers until we arrive at the root hash.
        // Each parent node is the hash of the two children below it.
        // E.g.,
        //              H0         <-- root (layer 2)
        //           /     \
        //        H1        H2
        //      /   \      /  \
        //    L1     L2  L3    L4  <--- leaves (layer 0)
        for (uint256 h = 1; h < height; ++h) {
            
            // calc no.f of hashes for that layer
            uint256 nHashes = (nodes.length + 1) / 2;       // (3+1)/2 = 2 | (4+1)/2 = 2
            bytes32[] memory hashes = new bytes32[](nHashes);   //bytes32[nHashes] memory hashes -> cre8 array based on number of hashes for that layer
            
            // nodes.length = total no. of members
            for (uint256 i = 0; i < nodes.length; i += 2) {
                
                bytes32 a = nodes[i];

                // Tree is sparse. Missing nodes will have a value of 0.
                bytes32 b = i + 1 < nodes.length ? nodes[i + 1] : bytes32(0);
                // Siblings are always hashed in sorted order.
                hashes[i / 2] = keccak256(a > b ? abi.encode(b, a) : abi.encode(a, b));     //0/2 = 0
            }

            tree[h] = nodes = hashes;
        }
        
        // Note the tree root is at the bottom.
        root = tree[height - 1][0];
    }

}

/*
Example: 4 members, 3 layers

    # calc height.
    everytime i move up the layers, the nodes are halved, cos pairwise multiplication. (take 2 -> 1)
    keep dividng by 2 tll you get 1
    
    height = 0;
    n:4 -> (4+1)/2 = 2, height = 1
    n:2 -> (2+1)/2 = 1, height = 2
    n:1 -> n=0, end loop. height = 3  [root is on layer 3]
    
    # create tree: top-level is height.
    bytes32[][3]tree;   --->tree[0], tree[1], tree[2]

    # 1st layer of tree contains leaves
    tree[0] -> leaves; 
    
    tree[0] = bytes32[](4); //create nested array of size 4 (no. of leaves)
    nodes[] = bytes32[](4)  //store hashed leaves

    # hash the leaves
    for(i=0 to i = 3){
        nodes[i] = hash(addr,amount);
    }

    # build up subseq. layers
    for(h = 1 to h = 2){    
        //calc. no of hashed for that layer
        uint256 nHashes = (nodes.length + 1) / 2; 
    }
        
        
// h = 1, LAYER 1
    
    # there are 2 hashes in layer 1 
    nHashes = (4+1)/2 = 2
    bytes32[2] memory hashes

    //pairwise hashing for that layer: so increment by 2. hash(a,b), hash(c,d)
    for(uint256 i = 0; i < nodes.length = 4; i += 2){

        i:0 -> hash[0] = hash(nodes[0], nodes[1])
        i:2 -> hash[1] = hash(nodes[2], nodes[3])
    }

    tree[1] = hashes;
    nodes = hashes;     //nodes.length = 2. contains H1,H2

    
// h = 2, LAYER 2


    # there is 1 hashes in layer 2 
    nHashes = (2+1)/2 = 1
    bytes32[1] memory hashes

    for(uint256 i = 0; i < nodes.length = 2; i += 2){
        a = nodes[0]    //H1
        b = nodes[1]    //H2

        i:0 -> hash[0] = hash(nodes[0], nodes[1])
    }

    tree[2] = hashes;
    nodes = hashes;     //nodes.length = 1. contains root
    
*/

/*
 root = tree[height - 1][0]  = tree[3 - 1][0];  
 
 //last top-level element: get the 1st elem in nested array.
 // cos there shld only be 1. 
 */